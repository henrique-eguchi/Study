import UIKit

// MARK: - Classes, Structs, Actors & Enums

/// Class is `reference type` - you send a reference when it gets passed around
/// Class has inheritance
/// Class instances can be either mutable or immutable, depending on whether they are declared with `var` or `let`
/// Instances of classes are reference types and live on the heap. The variable holding a reference to a class instance stores the memory address of the instance, and the actual instance is on the heap.
/// Usage: When you do got behavior: logic, use cases, need inheritance...
/// Analogy: It is like changing a shared Google Sheet with others.
final class Car {
    var year: Int
    var make: String
    var color: String

    init(
        year: Int,
        make: String,
        color: String
    ) {
        self.year = year
        self.make = make
        self.color = color
    }
}

// Tests

var myCar = Car(year: 2022, make: "Porsche", color: "Red")
var stolenCar = myCar
// Change reference's property
stolenCar.color = "Yellow"
print(myCar.color) // Print out "Yellow" even if you are referencing `myCar` object.

print("-------------")

/// Instances of struct are `value type` - you copy the object when it gets passed around
/// Struct does not have inheritance
/// Analogy - It is like creating a copy of a sheet by downloading it and change it locally.
/// Structs has member-wise initialization which means there's no need for having constructor since you got one for free.
/// They can be stored on the stack when they are part of a function's local variables or on the heap when they are part of a reference type (e.g., a class).
/// Usage: Aim to create structs for pure data, immutable, and no-behavior, SwiftUI views - Structs are lightweight & performant
struct SecondCar {
    var year: Int
    var make: String
    var color: String
}

// Tests

var mySecondCar = SecondCar(year: 2022, make: "McLaren", color: "Orange")
var secondStolenCar = mySecondCar
// Change copied's property
secondStolenCar.color = "Black"
print(mySecondCar.color) // Still "Orange"
print(secondStolenCar.color) // Copied car is "Black"

print("-------------")


// MARK: - Actors

/// Actor is a `reference type` with concurrency support, ensuring thread safety.
/// Analogy - It is like having a dedicated person (actor) managing a shared Google Sheet to prevent conflicts.
/// Actors are a concurrency feature introduced in Swift to handle shared mutable state in a safe way. The state of an actor is stored in heap-allocated memory.
/// Usage: When you need a threa-safe component and are comfortable/happy with extra async/await complexity for concurrent programming.

actor SafeCar {
    private var year: Int
    private var make: String
    private var color: String

    init(
        year: Int,
        make: String,
        color: String
    ) {
        self.year = year
        self.make = make
        self.color = color
    }

    // Actor-isolated method to safely access and modify properties
    func updateColor(to newColor: String) {
        color = newColor
    }

    // Actor-isolated method to safely retrieve the color
    func getColor() -> String {
        return color
    }
}

// Tests

// Creating an instance of the SafeCar actor
let mySafeCar = SafeCar(year: 2022, make: "Tesla", color: "Blue")

// Async call to update color, ensuring thread safety
Task {
    await mySafeCar.updateColor(to: "Green")
    print(await mySafeCar.getColor()) // Prints "Green"
}

// Accessing properties directly will result in a compile-time error due to actor isolation
// Uncommenting the line below will result in a compilation error:
//print(mySafeCar.getColor())

print("-------------")


// MARK: - Enums

/// Enums are `value types` like structs
/// It does not support inheritance
/// Enums, by default, create immutable instances. However, like `structs`, you can use `mutating` keyword on enum methods to explicitly allow modifications to enum cases
/// Enums can have associated values, which allows associating additional data with each case. This makes enums powerful for modeling different states or scenarios.
/// Enums, like `structs`, have a simple memberwise initializer generated by Swift. You can also provide custom initializers for enums.
/// Instances of enums are value types and can be stored on the stack or heap, depending on their context. If an enum has associated values with reference types, it might be allocated on the heap.
/// Usage: Enumerations are typically used for defining a finite set of related values, and they do not have the hierarchical structure that classes can have.


enum CarType {
    case suv
    case sedan
    case coupe
    case hypercar
}


// MARK: - Review / Questions

// Classes

/// 1. What is the key difference between a class and a struct in Swift?
/// 2. What is inheritance, and how does it work in classes?

// Structs

/// 1. Why are structs considered lightweight, and what is member-wise initialization?
/// 2. When is it appropriate to use a struct over a class?
/// 3. Why does structs has member-wise initialization and classes don't?

// Actors

/// 1. What is an actor in Swift, and why would you use it?
/// 2. How does actor isolation work, and why is it important for concurrency?

// Enums

/// 1. What is the fundamental similarity between enums and structs?
/// 2. True or False: Enums support inheritance in Swift.
/// 3. What is the default nature of instances created from enums?
/// 4. What does the mutating keyword signify in the context of enums?
/// 5. Explain the purpose of associated values in enums.
/// 6. What kind of initializer is generated by Swift for enums?
/// 7. How are instances of enums stored in terms of memory (stack or heap)?
/// 8. When might an enum with associated values be allocated on the heap?

// MARK: - Answers

// Classes

/// 1. The key difference is that classes are reference types, meaning when they are assigned
/// to a new constant or variable or passed as a function parameter, they are passed by reference.
/// Structs, on the other hand, are value types and are passed by value.

/// 2. Inheritance is a mechanism in which a class can inherit properties and methods from
/// another class. The class that is being inherited from is called the superclass, and the class
/// that inherits is called the subclass. Subclasses can override or extend the functionality of the
/// superclass.

// Structs

/// 1. Structs are considered lightweight because they are value types and are stored directly
/// where they are defined, eliminating the need for reference counting. Member-wise initialization
/// is a feature of structs where you get a default initializer that takes parameters for all the
/// properties of the struct. This initializer is automatically generated by the compiler.

/// 2. Structs are appropriate when you are dealing with simple data structures or when you
/// want value semantics. They are especially useful for representing immutable data, and they are
/// commonly used in Swift for things like representing points, sizes, and colors.

/// 3. Structs have member-wise initialization because they are lightweight value types and designed to be simple. 
/// Classes don't have this by default as they are reference types, often with more complexity and having member-wise 
/// initialization might not suit their design goals. 
/// While classes can have custom initializers, the absence of member-wise initialization emphasizes the distinction 
/// between the simplicity of value types (structs) and the flexibility of reference types (classes). 
/// It encourages developers to provide more structured and controlled initialization processes for classes, considering 
/// their potential complexity and the need for managing shared references.

// Actors

/// 1. An actor is a type that provides isolation for mutable state to ensure that only one
/// task can access that state at a time. Actors are used when you need to ensure thread safety in
/// a concurrent environment. They support asynchronous programming using `async` and `await` to
/// manage concurrent tasks.

/// 2. Actor isolation ensures that only one task (thread) can access the mutable state of an
/// actor at a time. All methods and properties of an actor are inherently isolated, meaning they
/// are protected from concurrent access. This is important for concurrency to prevent race
/// conditions and data inconsistencies that can arise when multiple tasks modify shared state
/// simultaneously.

// Enums

/// 1. They're both value types.
/// 2. False.
/// 3. Instances created from enums are immutable by default.
/// 4. The mutating keyword allows modifications to enum cases.
/// 5. Associated values in enums allow associating additional data with each case.
/// 6. Swift generates a simple memberwise initializer for enums.
/// 7. Instances of enums can be stored on the stack or heap, depending on their context.
/// 8. An enum with associated values might be allocated on the heap if it contains reference types.
